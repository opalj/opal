/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj.fpcf.fixtures.string;

import org.opalj.fpcf.properties.string_analysis.*;

import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * @see SimpleStringOps
 */
public class ExceptionalControlStructures {

    /**
     * Serves as the sink for string variables to be analyzed.
     */
    public void analyzeString(String s) {}

    // Multiple calls to "analyzeString" are generated by the Java compiler, hence we have multiple definitions
    @Failure(n = 0, levels = Level.L0)
    @Failure(n = 1, levels = Level.L0)
    @Failure(n = 2, levels = Level.L0)
    @PartiallyConstant(n = 0, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "File Content:.*")
    @PartiallyConstant(n = 1, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(File Content:|File Content:.*)")
    @PartiallyConstant(n = 2, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(File Content:|File Content:.*)")
    public void tryFinally(String filename) {
        StringBuilder sb = new StringBuilder("File Content:");
        try {
            String data = new String(Files.readAllBytes(Paths.get(filename)));
            sb.append(data);
        } catch (Exception ignore) {
        } finally {
            analyzeString(sb.toString());
        }
    }

    @Failure(n = 0, levels = Level.L0)
    @Failure(n = 1, levels = Level.L0)
    @Failure(n = 2, levels = Level.L0)
    @PartiallyConstant(n = 0, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "=====.*")
    // Exception case without own thrown exception
    @PartiallyConstant(n = 1, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(=====.*=====|==========)")
    // The following cases are detected:
    // 1. Code around Files.readAllBytes failing, throwing a non-exception Throwable -> no append (Pos 1)
    // 2. Code around Files.readAllBytes failing, throwing an exception Throwable -> exception case append (Pos 4)
    // 3. First append succeeds, throws no exception -> only first append (Pos 2)
    // 4. First append is executed but throws an exception Throwable -> both appends (Pos 3)
    @PartiallyConstant(n = 2, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(=====|=====.*|=====.*=====|==========)")
    public void tryCatchFinally(String filename) {
        StringBuilder sb = new StringBuilder("=====");
        try {
            String data = new String(Files.readAllBytes(Paths.get(filename)));
            sb.append(data);
        } catch (Exception ignore) {
            sb.append("=====");
        } finally {
            analyzeString(sb.toString());
        }
    }

    @Failure(n = 0, levels = Level.L0)
    @Failure(n = 1, levels = Level.L0)
    @Failure(n = 2, levels = Level.L0)
    @PartiallyConstant(n = 0, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "BOS:.*")
    @PartiallyConstant(n = 1, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(BOS:.*:EOS|BOS::EOS)")
    @PartiallyConstant(n = 2, levels = Level.TRUTH, soundness = SoundnessMode.HIGH, value = "(BOS:.*:EOS|BOS::EOS)")
    public void tryCatchFinallyWithThrowable(String filename) {
        StringBuilder sb = new StringBuilder("BOS:");
        try {
            String data = new String(Files.readAllBytes(Paths.get(filename)));
            sb.append(data);
        } catch (Throwable t) {
            sb.append(":EOS");
        } finally {
            analyzeString(sb.toString());
        }
    }
}
