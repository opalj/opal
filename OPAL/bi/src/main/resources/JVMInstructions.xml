<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="JVMInstructions.css"?>
<!--
  License (BSD Style License):
  Copyright (c) 2009, 2011
  Software Technology Group
  Department of Computer Science
  Technische Universität Darmstadt
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

  - Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
  - Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
  - Neither the name of the Software Technology Group or Technische
    Universität Darmstadt nor the names of its contributors may be used to
    endorse or promote products derived from this software without specific
    prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
-->
<instructions xsi:schemaLocation="https://www.opal-project.de/bi/JVMInstructions JVMInstructions.xsd"
	xmlns="https://www.opal-project.de/bi/JVMInstructions" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xhtml="http://www.w3.org/1999/xhtml">

	<documentation>
		<xhtml:div id="title">
			List of all Java bytecode instructions as defined in the Java Virtual Machine Specification
			4th Edition (Java 1.1 … Java 7).
		</xhtml:div>
		This list is compiled by Michael Eichberg (mail@michael-eichberg.de)
	    <xhtml:div>
   	    Created October 2009<xhtml:br />
		Updated September 2011 - Java 7<xhtml:br />
	    </xhtml:div>
   </documentation>

	<instruction name="aaload" opcode="50">
		<operation>Load reference from array</operation>
		<parameterized base="arrayload">
			<type name="reference" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="aastore" opcode="83">
		<operation>Store into reference array</operation>
		<parameterized base="arraystore">
			<type name="reference" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
			<exception type="java.lang.ArrayStoreException" />
		</exceptions>
	</instruction>
	<instruction name="aconst_null" opcode="1">
		<operation>Push null</operation>
		<parameterized base="push">
			<type name="reference" value="null" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="aload" opcode="25">
		<operation>Load reference from local variable</operation>
		<parameterized base="load">
			<type name="reference" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ubyte" id="lvIndex" />
			</std>
			<wide>
				<el type="mnemonic" />
				<el type="ushort" id="lvIndex" />
			</wide>
		</format>
	</instruction>
	<instruction name="aload_0" opcode="42">
		<operation>Load reference from local variable with index 0</operation>
		<specialized base="aload">
			<parameter id="lvIndex" value="0" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="aload_1" opcode="43">
		<operation>Load reference from local variable with index 1</operation>
		<specialized base="aload">
			<parameter id="lvIndex" value="1" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="aload_2" opcode="44">
		<operation>Load reference from local variable with index 2</operation>
		<specialized base="aload">
			<parameter id="lvIndex" value="2" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="aload_3" opcode="45">
		<operation>Load reference from local variable with index 3</operation>
		<specialized base="aload">
			<parameter id="lvIndex" value="3" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="anewarray" opcode="189">
		<operation>Create new array of reference</operation>
		<parameterized base="newarray">
			<type name="reference" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ushort_cp_index->referenceType" id="componentType" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NegativeArraySizeException" />
		</exceptions>
	</instruction>
	<instruction name="areturn" opcode="176">
		<operation>Return reference from method</operation>
		<parameterized base="return">
			<type name="reference" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="arraylength" opcode="190">
		<operation>Get length of array</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
		</exceptions>
	</instruction>
	<instruction name="astore" opcode="58">
		<operation>Store reference into local variable</operation>
		<parameterized base="store">
			<type name="reference_or_return_address" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ubyte" id="lvIndex" />
			</std>
			<wide>
				<el type="mnemonic" />
				<el type="ushort" id="lvIndex" />
			</wide>
		</format>
	</instruction>
	<instruction name="astore_0" opcode="75">
		<operation>Store reference into local variable with index 0</operation>
		<specialized base="astore">
			<parameter id="lvIndex" value="0" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="astore_1" opcode="76">
		<operation>Store reference into local variable with index 1</operation>
		<specialized base="astore">
			<parameter id="lvIndex" value="1" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="astore_2" opcode="77">
		<operation>Store reference into local variable with index 2</operation>
		<specialized base="astore">
			<parameter id="lvIndex" value="2" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="astore_3" opcode="78">
		<operation>Store reference into local variable with index 3</operation>
		<specialized base="astore">
			<parameter id="lvIndex" value="3" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="athrow" opcode="191">
		<operation>Throw exception or error</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.IllegalMonitorStateException" />
		</exceptions>
	</instruction>
	<instruction name="baload" opcode="51">
		<operation>Load byte or boolean from array</operation>
		<parameterized base="arrayload">
			<type name="byte_or_boolean" /><!-- The type is either byte or boolean... -->
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="bastore" opcode="84">
		<operation>Store into byte or boolean array</operation>
		<parameterized base="arraystore">
			<type name="byte_or_boolean" /><!-- The type is either byte or boolean... -->
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="bipush" opcode="16">
		<operation>Push byte</operation>
		<parameterized base="push">
			<type name="byte" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="byte" id="value" />
			</std>
		</format>
	</instruction>
	<instruction name="caload" opcode="52">
		<operation>Load char from array</operation>
		<parameterized base="arrayload">
			<type name="char" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="castore" opcode="85">
		<operation>Store into char array</operation>
		<parameterized base="arraystore">
			<type name="char" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="checkcast" opcode="192">
		<operation>Check whether object is of given type</operation>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ushort_cp_index->referenceType" id="referenceType" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.ClassCastException" />
		</exceptions>
	</instruction>
	<instruction name="d2f" opcode="144">
		<operation>Convert double to float</operation>
		<parameterized base="cast">
			<type name="double" />
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="d2i" opcode="142">
		<operation>Convert double to int</operation>
		<parameterized base="cast">
			<type name="double" />
			<type name="int" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="d2l" opcode="143">
		<operation>Convert double to long</operation>
		<parameterized base="cast">
			<type name="double" />
			<type name="long" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dadd" opcode="99">
		<operation>Add double</operation>
		<parameterized base="add">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="daload" opcode="49">
		<operation>Load double from array</operation>
		<parameterized base="arrayload">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="dastore" opcode="82">
		<operation>Store into double array</operation>
		<parameterized base="arraystore">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="dcmpg" opcode="152">
		<operation>Compare double</operation>
		<parameterized base="cmp">
			<type name="double" />
			<classifier name="g" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dcmpl" opcode="151">
		<operation>Compare double</operation>
		<parameterized base="cmp">
			<type name="double" />
			<classifier name="l" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dconst_0" opcode="14">
		<operation>Push the double constant 0.0 onto the operand stack</operation>
		<parameterized base="push">
			<type name="double" value="0" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dconst_1" opcode="15">
		<operation>Push the double constant 1.0 onto the operand stack</operation>
		<parameterized base="push">
			<type name="double" value="1" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="ddiv" opcode="111">
		<operation>Divide double</operation>
		<parameterized base="div">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dload" opcode="24">
		<operation>Load double from local variable</operation>
		<parameterized base="load">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ubyte" id="lvIndex" />
			</std>
			<wide>
				<el type="mnemonic" />
				<el type="ushort" id="lvIndex" />
			</wide>
		</format>
	</instruction>
	<instruction name="dload_0" opcode="38">
		<operation>Load double from local variable with index 0</operation>
		<specialized base="dload">
			<parameter id="lvIndex" value="0" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dload_1" opcode="39">
		<operation>Load double from local variable with index 1</operation>
		<specialized base="dload">
			<parameter id="lvIndex" value="1" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dload_2" opcode="40">
		<operation>Load double from local variable with index 2</operation>
		<specialized base="dload">
			<parameter id="lvIndex" value="2" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dload_3" opcode="41">
		<operation>Load double from local variable with index 3</operation>
		<specialized base="dload">
			<parameter id="lvIndex" value="3" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dmul" opcode="107">
		<operation>Multiply double</operation>
		<parameterized base="mul">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dneg" opcode="119">
		<operation>Negate double</operation>
		<parameterized base="neg">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="drem" opcode="115">
		<operation>Remainder double</operation>
		<parameterized base="rem">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dreturn" opcode="175">
		<operation>Return double from method</operation>
		<parameterized base="return">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.IllegalMonitorStateException" />
		</exceptions>
	</instruction>
	<instruction name="dstore" opcode="57">
		<operation>Store double into local variable</operation>
		<parameterized base="store">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ubyte" id="lvIndex" />
			</std>
			<wide>
				<el type="mnemonic" />
				<el type="ushort" id="lvIndex" />
			</wide>
		</format>
	</instruction>
	<instruction name="dstore_0" opcode="71">
		<operation>Store double into local variable with index 0</operation>
		<specialized base="dstore">
			<parameter id="lvIndex" value="0" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dstore_1" opcode="72">
		<operation>Store double into local variable with index 1</operation>
		<specialized base="dstore">
			<parameter id="lvIndex" value="1" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dstore_2" opcode="73">
		<operation>Store double into local variable with index 2</operation>
		<specialized base="dstore">
			<parameter id="lvIndex" value="2" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dstore_3" opcode="74">
		<operation>Store double into local variable with index 3</operation>
		<specialized base="dstore">
			<parameter id="lvIndex" value="3" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dsub" opcode="103">
		<operation>Subtract double</operation>
		<parameterized base="sub">
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dup" opcode="89">
		<operation>Duplicate the top operand stack value</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dup_x1" opcode="90">
		<operation>Duplicate the top operand stack value and insert two values down.</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dup_x2" opcode="91">
		<operation>Duplicate the top operand stack value and insert two or three values
			down</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dup2" opcode="92">
		<operation>Duplicate the top one or two operand stack values</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dup2_x1" opcode="93">
		<operation>Duplicate the top one or two operand stack values and insert two or
			three values down</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="dup2_x2" opcode="94">
		<operation>Duplicate the top one or two operand stack values and insert two,
			three, or four values down</operation>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="f2d" opcode="141">
		<operation>Convert float to double</operation>
		<parameterized base="cast">
			<type name="float" />
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="f2i" opcode="139">
		<operation>Convert float to int</operation>
		<parameterized base="cast">
			<type name="float" />
			<type name="int" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="f2l" opcode="140">
		<operation>Convert float to long</operation>
		<parameterized base="cast">
			<type name="float" />
			<type name="long" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fadd" opcode="98">
		<operation>Add float</operation>
		<parameterized base="add">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="faload" opcode="48">
		<operation>Load float from array</operation>
		<parameterized base="arrayload">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="fastore" opcode="81">
		<operation>Store into float array</operation>
		<parameterized base="arraystore">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="fcmpg" opcode="150">
		<operation>Compare float</operation>
		<parameterized base="cmp">
			<type name="float" />
			<classifier name="g" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fcmpl" opcode="149">
		<operation>Compare float</operation>
		<parameterized base="cmp">
			<type name="float" />
			<classifier name="l" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fconst_0" opcode="11">
		<operation>Push the float constant 0.0 onto the operand stack</operation>
		<parameterized base="push">
			<type name="float" value="0" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fconst_1" opcode="12">
		<operation>Push the float constant 1.0 onto the operand stack</operation>
		<parameterized base="push">
			<type name="float" value="1" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fconst_2" opcode="13">
		<operation>Push the float constant 2.0 onto the operand stack</operation>
		<parameterized base="push">
			<type name="float" value="2" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fdiv" opcode="110">
		<operation>Divide float</operation>
		<parameterized base="div">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fload" opcode="23">
		<operation>Load float from local variable</operation>
		<parameterized base="load">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ubyte" id="lvIndex" />
			</std>
			<wide>
				<el type="mnemonic" />
				<el type="ushort" id="lvIndex" />
			</wide>
		</format>
	</instruction>
	<instruction name="fload_0" opcode="34">
		<operation>Load float from local variable with index 0</operation>
		<specialized base="fload">
			<parameter id="lvIndex" value="0" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fload_1" opcode="35">
		<operation>Load float from local variable with index 1</operation>
		<specialized base="fload">
			<parameter id="lvIndex" value="1" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fload_2" opcode="36">
		<operation>Load float from local variable with index 2</operation>
		<specialized base="fload">
			<parameter id="lvIndex" value="2" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fload_3" opcode="37">
		<operation>Load float from local variable with index 3</operation>
		<specialized base="fload">
			<parameter id="lvIndex" value="3" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fmul" opcode="106">
		<operation>Multiply float</operation>
		<parameterized base="mul">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fneg" opcode="118">
		<operation>Negate float</operation>
		<parameterized base="neg">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="frem" opcode="114">
		<operation>Remainder float</operation>
		<parameterized base="rem">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="freturn" opcode="174">
		<operation>Return float from method</operation>
		<parameterized base="return">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.IllegalMonitorStateException" />
		</exceptions>
	</instruction>
	<instruction name="fstore" opcode="56">
		<operation>Store float into local variable</operation>
		<parameterized base="store">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ubyte" id="lvIndex" />
			</std>
			<wide>
				<el type="mnemonic" />
				<el type="ushort" id="lvIndex" />
			</wide>
		</format>
	</instruction>
	<instruction name="fstore_0" opcode="67">
		<operation>Store float into local variable with index 0</operation>
		<specialized base="fstore">
			<parameter id="lvIndex" value="0" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fstore_1" opcode="68">
		<operation>Store float into local variable with index 1</operation>
		<specialized base="fstore">
			<parameter id="lvIndex" value="1" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fstore_2" opcode="69">
		<operation>Store float into local variable with index 2</operation>
		<specialized base="fstore">
			<parameter id="lvIndex" value="2" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fstore_3" opcode="70">
		<operation>Store float into local variable with index 3</operation>
		<specialized base="fstore">
			<parameter id="lvIndex" value="3" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="fsub" opcode="102">
		<operation>Subtract float</operation>
		<parameterized base="sub">
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="getfield" opcode="180">
		<operation>Fetch ﬁeld from object</operation>
		<parameterized base="get">
			<classifier name="field" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ushort_cp_index->fieldref" id="fieldref" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
		</exceptions>
	</instruction>
	<instruction name="getstatic" opcode="178">
		<operation>Getstatic ﬁeld from class</operation>
		<parameterized base="get">
			<classifier name="static" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="ushort_cp_index->fieldref" id="fieldref" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.ExceptionInInitializerError" />
		</exceptions>
	</instruction>
	<instruction name="goto" opcode="167">
		<operation>Branch always</operation>
		<specialized base="goto_w"><!-- goto_w can represent goto, but not the other way round! -->
			<parameter id="branchoffset" value="$branchoffset" />
		</specialized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="branchoffset" id="branchoffset" />
			</std>
		</format>
	</instruction>
	<instruction name="goto_w" opcode="200">
		<operation>Branch always</operation>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="branchoffset_wide" id="branchoffset" />
			</std>
		</format>
	</instruction>
	<instruction name="i2b" opcode="145">
		<operation>Convert int to byte</operation>
		<parameterized base="cast">
			<type name="int" />
			<type name="byte" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="i2c" opcode="146">
		<operation>Convert int to char</operation>
		<parameterized base="cast">
			<type name="int" />
			<type name="char" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="i2d" opcode="135">
		<operation>Convert int to double</operation>
		<parameterized base="cast">
			<type name="int" />
			<type name="double" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="i2f" opcode="134">
		<operation>Convert int to float</operation>
		<parameterized base="cast">
			<type name="int" />
			<type name="float" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="i2l" opcode="133">
		<operation>Convert int to long</operation>
		<parameterized base="cast">
			<type name="int" />
			<type name="long" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="i2s" opcode="147">
		<operation>Convert int to short</operation>
		<parameterized base="cast">
			<type name="int" />
			<type name="short" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iadd" opcode="96">
		<operation>Add int</operation>
		<parameterized base="add">
			<type name="int" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iaload" opcode="46">
		<operation>Load int from array</operation>
		<parameterized base="arrayload">
			<type name="int" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="iand" opcode="126">
		<operation>Boolean AND int</operation>
		<parameterized base="and">
			<type name="int" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iastore" opcode="79">
		<operation>Store into int array</operation>
		<parameterized base="arraystore">
			<type name="int" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException" />
			<exception type="java.lang.ArrayIndexOutOfBoundsException" />
		</exceptions>
	</instruction>
	<instruction name="iconst_m1" opcode="2">
		<operation>Push int constant</operation>
		<parameterized base="push">
			<type name="int" value="-1" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iconst_0" opcode="3">
		<operation>Push int constant</operation>
		<parameterized base="push">
			<type name="int" value="0" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iconst_1" opcode="4">
		<operation>Push int constant</operation>
		<parameterized base="push">
			<type name="int" value="1" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iconst_2" opcode="5">
		<operation>Push int constant</operation>
		<parameterized base="push">
			<type name="int" value="2" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iconst_3" opcode="6">
		<operation>Push int constant</operation>
		<parameterized base="push">
			<type name="int" value="3" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iconst_4" opcode="7">
		<operation>Push int constant</operation>
		<parameterized base="push">
			<type name="int" value="4" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="iconst_5" opcode="8">
		<operation>Push int constant</operation>
		<parameterized base="push">
			<type name="int" value="5" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
	</instruction>
	<instruction name="idiv" opcode="108">
		<operation>Divide int</operation>
		<parameterized base="div">
			<type name="int" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.ArithmeticException" />
		</exceptions>
	</instruction>
	<instruction name="if_acmpeq" opcode="165">
		<operation>Branch if reference comparison succeeds; succeeds if and only if value1 = value2</operation>
		<parameterized base="if_cmp">
			<type name="reference" />
			<operator name="eq" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="branchoffset" id="branchoffset" />
			</std>
		</format>
	</instruction>
	<instruction name="if_acmpne" opcode="166">
		<operation>Branch if reference comparison succeeds; succeeds if and only if value1 ≠ value2</operation>
		<parameterized base="if_cmp">
			<type name="reference" />
			<operator name="ne" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="branchoffset" id="branchoffset" />
			</std>
		</format>
	</instruction>
	<instruction name="if_icmpeq" opcode="159">
		<operation>Branch if int comparison succeeds; succeeds if and only if value1 = value2</operation>
		<parameterized base="if_cmp">
			<type name="int" />
			<operator name="eq" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="branchoffset" id="branchoffset" />
			</std>
		</format>
	</instruction>
	<instruction name="if_icmpne" opcode="160">
		<operation>Branch if int comparison succeeds; succeeds if and only if value1 ≠ value2</operation>
		<parameterized base="if_cmp">
			<type name="int" />
			<operator name="ne" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic" />
				<el type="branchoffset" id="branchoffset" />
			</std>
		</format>
	</instruction>
	<instruction name="if_icmplt" opcode="161">
		<operation>Branch if int comparison succeeds; succeeds if and only if value1 &lt; value2</operation>
		<parameterized base="if_cmp">
			<type name="int"/>
			<operator name="lt"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="if_icmpge" opcode="162">
		<operation>Branch if int comparison succeeds; succeeds if and only if value1 ≥ value2</operation>
		<parameterized base="if_cmp">
			<type name="int"/>
			<operator name="ge"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="if_icmpgt" opcode="163">
		<operation>Branch if int comparison succeeds; succeeds if and only if value1 &gt; value2</operation>
		<parameterized base="if_cmp">
			<type name="int"/>
			<operator name="gt"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="if_icmple" opcode="164">
		<operation>Branch if int comparison succeeds; succeeds if and only if value1 ≤ value2</operation>
		<parameterized base="if_cmp">
			<type name="int"/>
			<operator name="le"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="ifeq" opcode="153">
		<operation>Branch if int comparison with zero succeeds; succeeds if and only if value = 0</operation>
		<parameterized base="if">
			<operator name="eq"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="ifne" opcode="154">
		<operation>Branch if int comparison with zero succeeds; succeeds if and only if value ≠ 0</operation>
		<parameterized base="if">
			<operator name="ne"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="iflt" opcode="155">
		<operation>Branch if int comparison with zero succeeds; succeeds if and only if value &lt; 0</operation>
		<parameterized base="if">
			<operator name="lt"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="ifge" opcode="156">
		<operation>Branch if int comparison with zero succeeds; succeeds if and only if value ≥ 0</operation>
		<parameterized base="if">
			<operator name="ge"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="ifgt" opcode="157">
		<operation>Branch if int comparison with zero succeeds; succeeds if and only if value &gt; 0</operation>
		<parameterized base="if">
			<operator name="gt"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="ifle" opcode="158">
		<operation>Branch if int comparison with zero succeeds; succeeds if and only if value ≤ 0</operation>
		<parameterized base="if">
			<operator name="le"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="ifnonnull" opcode="199">
		<operation>Branch if reference is not null</operation>
		<parameterized base="if">
			<classifier name="nonnull"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="ifnull" opcode="198">
		<operation>Branch if reference is null</operation>
		<parameterized base="if">
			<classifier name="null"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="iinc" opcode="132">
		<operation>Increment local variable by constant</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ubyte" id="lvIndex"/>
				<el type="byte" id="constValue"/>
			</std>
			<wide>
				<el type="mnemonic"/>
				<el type="ushort" id="lvIndex"/>
				<el type="short" id="constValue"/>
			</wide>
		</format>
	</instruction>
	<instruction name="iload" opcode="21">
		<operation>Load int from local variable</operation>
		<parameterized base="load">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ubyte" id="lvIndex"/>
			</std>
			<wide>
				<el type="mnemonic"/>
				<el type="ushort" id="lvIndex"/>
			</wide>
		</format>
	</instruction>
	<instruction name="iload_0" opcode="26">
		<operation>Load int from local variable with index 0</operation>
		<specialized base="iload">
			<parameter id="lvIndex" value="0"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="iload_1" opcode="27">
		<operation>Load int from local variable with index 1</operation>
		<specialized base="iload">
			<parameter id="lvIndex" value="1"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="iload_2" opcode="28">
		<operation>Load int from local variable with index 2</operation>
		<specialized base="iload">
			<parameter id="lvIndex" value="2"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="iload_3" opcode="29">
		<operation>Load int from local variable with index 3</operation>
		<specialized base="iload">
			<parameter id="lvIndex" value="3"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="imul" opcode="104">
		<operation>Multiply int</operation>
		<parameterized base="mul">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="ineg" opcode="116">
		<operation>Negate int</operation>
		<parameterized base="neg">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="instanceof" opcode="193">
		<operation>Determine if object is of given type</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->referenceType" id="referenceType"/>
			</std>
		</format>
	</instruction>
	<instruction name="invokedynamic" opcode="186">
		<operation>Invoke instance method; resolve and dispatch based on class</operation>
		<parameterized base="invoke">
			<classifier name="dynamic"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->call_site_specifier" id="callSiteSpecifier"/>
				<el type="IGNORE"/><!-- is always zero... -->
				<el type="IGNORE"/><!-- is always zero... -->
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
		</exceptions>
	</instruction>
	<instruction name="invokeinterface" opcode="185">
		<operation>Invoke interface method</operation>
		<parameterized base="invoke">
			<classifier name="interface"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->interface_methodref" id="methodRef"/>
				<el type="IGNORE" id="count"/><!--<el type="ubyte" id="count"/>--> <!-- The value can be ignored, it does not affect the runtime. -->
				<el type="IGNORE"/><!-- is always zero... -->
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
		</exceptions>
	</instruction>
	<instruction name="invokespecial" opcode="183">
		<operation>Invoke instance method; special handling for superclass, private,
			and instance initialization method invocations</operation>
		<parameterized base="invoke">
			<classifier name="special"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->methodref" id="methodRef"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
		</exceptions>
	</instruction>
	<instruction name="invokestatic" opcode="184">
		<operation>Invoke a class (static) method</operation>
		<parameterized base="invoke">
			<classifier name="static"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->methodref" id="methodRef"/>
			</std>
		</format>
	</instruction>
	<instruction name="invokevirtual" opcode="182">
		<operation>Invoke instance method; dispatch based on class</operation>
		<parameterized base="invoke">
			<classifier name="virtual"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->methodref" id="methodRef"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
		</exceptions>
	</instruction>
	<instruction name="ior" opcode="128">
		<operation>Boolean OR int</operation>
		<parameterized base="or">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="irem" opcode="112">
		<operation>Remainder int</operation>
		<parameterized base="rem">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.ArithmeticException"/>
		</exceptions>
	</instruction>
	<instruction name="ireturn" opcode="172">
		<operation>Return int from method</operation>
		<parameterized base="return">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.IllegalMonitorStateException"/>
		</exceptions>
	</instruction>
	<instruction name="ishl" opcode="120">
		<operation>Shift left int</operation>
		<parameterized base="shl">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="ishr" opcode="122">
		<operation>Arithmetic shift right int</operation>
		<parameterized base="shr">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="istore" opcode="54">
		<operation>Store int into local variable</operation>
		<parameterized base="store">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ubyte" id="lvIndex"/>
			</std>
			<wide>
				<el type="mnemonic"/>
				<el type="ushort" id="lvIndex"/>
			</wide>
		</format>
	</instruction>
	<instruction name="istore_0" opcode="59">
		<operation>Store int into local variable with index 0</operation>
		<specialized base="istore">
			<parameter id="lvIndex" value="0"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="istore_1" opcode="60">
		<operation>Store int into local variable with index 1</operation>
		<specialized base="istore">
			<parameter id="lvIndex" value="1"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="istore_2" opcode="61">
		<operation>Store int into local variable with index 2</operation>
		<specialized base="istore">
			<parameter id="lvIndex" value="2"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="istore_3" opcode="62">
		<operation>Store int into local variable with index 3</operation>
		<specialized base="istore">
			<parameter id="lvIndex" value="3"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="isub" opcode="100">
		<operation>Subtract int</operation>
		<parameterized base="sub">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="iushr" opcode="124">
		<operation>Logical shift right int</operation>
		<parameterized base="ushr">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="ixor" opcode="130">
		<operation>Boolean XOR int</operation>
		<parameterized base="xor">
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="jsr" opcode="168" deprecated="1.6">
		<operation>Jump subroutine</operation>
		<specialized base="jsr_w">
			<parameter id="branchoffset" value="$branchoffset"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="jsr_w" opcode="201" deprecated="1.6">
		<operation>Jump subroutine</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="branchoffset_wide" id="branchoffset"/>
			</std>
		</format>
	</instruction>
	<instruction name="l2d" opcode="138">
		<operation>Convert long to double</operation>
		<parameterized base="cast">
			<type name="long"/>
			<type name="double"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="l2f" opcode="137">
		<operation>Convert long to float</operation>
		<parameterized base="cast">
			<type name="long"/>
			<type name="float"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="l2i" opcode="136">
		<operation>Convert long to int</operation>
		<parameterized base="cast">
			<type name="long"/>
			<type name="int"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="ladd" opcode="97">
		<operation>Add long</operation>
		<parameterized base="add">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="laload" opcode="47">
		<operation>Load long from array</operation>
		<parameterized base="arrayload">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
			<exception type="java.lang.ArrayIndexOutOfBoundsException"/>
		</exceptions>
	</instruction>
	<instruction name="land" opcode="127">
		<operation>Boolean AND long</operation>
		<parameterized base="and">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lastore" opcode="80">
		<operation>Store into long array</operation>
		<parameterized base="arraystore">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
			<exception type="java.lang.ArrayIndexOutOfBoundsException"/>
		</exceptions>
	</instruction>
	<instruction name="lcmp" opcode="148">
		<operation>Compare long</operation>
		<parameterized base="cmp">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lconst_0" opcode="9">
		<operation>Push the long constant 0 onto the operand stack</operation>
		<parameterized base="push">
			<type name="long" value="0"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lconst_1" opcode="10">
		<operation>Push the long constant 1 onto the operand stack</operation>
		<parameterized base="push">
			<type name="long" value="1"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="ldc" opcode="18">
		<operation>Push item from runtime constant pool</operation>
		<specialized base="ldc_w">
			<parameter id="constantValue" value="$constantValue"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ubyte_cp_index->constant_value" id="constantValue"><!--
					The index must be a valid index into the runtime constant pool of the current
					class. The runtime constant pool entry at the index either must be a  runtime
					constant of type int or float, or must be a symbolic reference to a class
					(§5.4.3.1) or a string literal (§5.1) or a method type or method handle
					($5.4.3.5) or a dynamically computed constant ($5.4.3.6) whose field descriptor
					is neither J (long) or D (double).
				--></el>
			</std>
		</format>
	</instruction>
	<instruction name="ldc_w" opcode="19">
		<operation>Push item from runtime constant pool</operation>
		<parameterized base="push" />
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->constant_value" id="constantValue"><!--
					The index must be a valid index into the runtime constant pool of the current
					class. The runtime constant pool entry at the index either must be a  runtime
					constant of type int or float, or must be a symbolic reference to a class
					(§5.4.3.1) or a string literal (§5.1) or a method type or method handle
					($5.4.3.5) or a dynamically computed constant ($5.4.3.6) whose field descriptor
					is neither J (long) or D (double).
				--></el>
			</std>
		</format>
	</instruction>
	<instruction name="ldc2_w" opcode="20">
		<operation>Push long or double from runtime constant pool</operation>
		<parameterized base="push" />
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->constant_value" id="constantValue"><!--
					The runtime constant pool entry at the index must be a runtime constant of type
					long or double (§5.1) or a dynamically computed constant ($5.4.3.6) whose field
					descriptor is either J (long) or D (doubler). The numeric value of that runtime
					constant is pushed onto the operand stack as a long or double, respectively.
				--></el>
			</std>
		</format>
	</instruction>
	<instruction name="ldiv" opcode="109">
		<operation>Divide long</operation>
		<parameterized base="div">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.ArithmeticException"/>
		</exceptions>
	</instruction>
	<instruction name="lload" opcode="22">
		<operation>Load long from local variable</operation>
		<parameterized base="load">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ubyte" id="lvIndex"/>
			</std>
			<wide>
				<el type="mnemonic"/>
				<el type="ushort" id="lvIndex"/>
			</wide>
		</format>
	</instruction>
	<instruction name="lload_0" opcode="30">
		<operation>Load long from local variable with index 0</operation>
		<specialized base="lload">
			<parameter id="lvIndex" value="0"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lload_1" opcode="31">
		<operation>Load long from local variable with index 1</operation>
		<specialized base="lload">
			<parameter id="lvIndex" value="1"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lload_2" opcode="32">
		<operation>Load long from local variable with index 2</operation>
		<specialized base="lload">
			<parameter id="lvIndex" value="2"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lload_3" opcode="33">
		<operation>Load long from local variable with index 3</operation>
		<specialized base="lload">
			<parameter id="lvIndex" value="3"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lmul" opcode="105">
		<operation>Multiply long</operation>
		<parameterized base="mul">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lneg" opcode="117">
		<operation>Negate long</operation>
		<parameterized base="neg">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lookupswitch" opcode="171">
		<operation>Access jump table by key match and jump</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="padding_bytes"/>
				<el type="branchoffset_wide" id="defaultOffset"/>
				<el type="int" id="npairsCount"/>
				<list count="$npairsCount" id="npairs">
					<el type="int" id="matchValue"/>
					<el type="branchoffset_wide" id="branchoffset"/>
				</list>
			</std>
		</format>
	</instruction>
	<instruction name="lor" opcode="129">
		<operation>Boolean OR long</operation>
		<parameterized base="or">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lrem" opcode="113">
		<operation>Remainder long</operation>
		<parameterized base="rem">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.ArithmeticException"/>
		</exceptions>
	</instruction>
	<instruction name="lreturn" opcode="173">
		<operation>Return long from method</operation>
		<parameterized base="return">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.IllegalMonitorStateException"/>
		</exceptions>
	</instruction>
	<instruction name="lshl" opcode="121">
		<operation>Shift left long</operation>
		<parameterized base="shl">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lshr" opcode="123">
		<operation>Arithmetic shift right long</operation>
		<parameterized base="shr">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lstore" opcode="55">
		<operation>Store long into local variable</operation>
		<parameterized base="store">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ubyte" id="lvIndex"/>
			</std>
			<wide>
				<el type="mnemonic"/>
				<el type="ushort" id="lvIndex"/>
			</wide>
		</format>
	</instruction>
	<instruction name="lstore_0" opcode="63">
		<operation>Store long into local variable with index 0</operation>
		<specialized base="lstore">
			<parameter id="lvIndex" value="0"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lstore_1" opcode="64">
		<operation>Store long into local variable with index 1</operation>
		<specialized base="lstore">
			<parameter id="lvIndex" value="1"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lstore_2" opcode="65">
		<operation>Store long into local variable with index 2</operation>
		<specialized base="lstore">
			<parameter id="lvIndex" value="2"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lstore_3" opcode="66">
		<operation>Store long into local variable with index 3</operation>
		<specialized base="lstore">
			<parameter id="lvIndex" value="3"/>
		</specialized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lsub" opcode="101">
		<operation>Subtract long</operation>
		<parameterized base="sub">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lushr" opcode="125">
		<operation>Logical shift right long</operation>
		<parameterized base="ushr">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="lxor" opcode="131">
		<operation>Boolean XOR long</operation>
		<parameterized base="xor">
			<type name="long"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="monitorenter" opcode="194">
		<operation>Enter monitor for object</operation>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
		</exceptions>
	</instruction>
	<instruction name="monitorexit" opcode="195">
		<operation>Exit monitor for object</operation>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
			<exception type="java.lang.IllegalMonitorStateException"/>
		</exceptions>
	</instruction>
	<instruction name="multianewarray" opcode="197">
		<operation>Create new multidimensional array</operation>
		<parameterized base="newarray">
			<type name="arrayref"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->referenceType" id="componentType"/>
				<el type="ubyte" id="dimensions"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NegativeArraySizeException"/>
		</exceptions>
	</instruction>
	<instruction name="new" opcode="187">
		<operation>Create new object</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<!-- The spec states that "new" is never to be used to create arrays. -->
				<el type="ushort_cp_index->objectType" id="objectType"/>
			</std>
		</format>
	</instruction>
	<instruction name="newarray" opcode="188">
		<operation>Create new arrayhandler</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="atype" id="atype"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NegativeArraySizeException"/>
		</exceptions>
	</instruction>
	<instruction name="nop" opcode="0">
		<operation>Do nothing</operation>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="pop" opcode="87">
		<operation>Pop the top operand stack value</operation>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="pop2" opcode="88">
		<operation>Pop the top one or two operand stack values</operation>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="putfield" opcode="181">
		<operation>Set field in object</operation>
		<parameterized base="put">
			<classifier name="field"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->fieldref" id="fieldref"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
		</exceptions>
	</instruction>
	<instruction name="putstatic" opcode="179">
		<operation>Set static field in class</operation>
		<parameterized base="put">
			<classifier name="static"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ushort_cp_index->fieldref" id="fieldref"/>
			</std>
		</format>
	</instruction>
	<instruction name="ret" opcode="169" deprecated="1.6">
		<operation>Return from subroutine</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="ubyte" id="lvIndex"/>
			</std>
			<wide>
				<el type="mnemonic"/>
				<el type="ushort" id="lvIndex"/>
			</wide>
		</format>
	</instruction>
	<instruction name="return" opcode="177">
		<operation>Return void from method</operation>
		<parameterized base="return">
			<type name="void" />
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.IllegalMonitorStateException"/>
		</exceptions>
	</instruction>
	<instruction name="saload" opcode="53">
		<operation>Load short from array</operation>
		<parameterized base="arrayload">
			<type name="short"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
			<exception type="java.lang.ArrayIndexOutOfBoundsException"/>
		</exceptions>
	</instruction>
	<instruction name="sastore" opcode="86">
		<operation>Store into short array</operation>
		<parameterized base="arraystore">
			<type name="short"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
		<exceptions>
			<exception type="java.lang.NullPointerException"/>
			<exception type="java.lang.ArrayIndexOutOfBoundsException"/>
		</exceptions>
	</instruction>
	<instruction name="sipush" opcode="17">
		<operation>Push short</operation>
		<parameterized base="push">
			<type name="short"/>
		</parameterized>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="short" id="value"/>
			</std>
		</format>
	</instruction>
	<instruction name="swap" opcode="95">
		<operation>Swap the top two operand stack values</operation>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
	<instruction name="tableswitch" opcode="170">
		<operation>Access jump table by index and jump</operation>
		<format>
			<std>
				<el type="mnemonic"/>
				<el type="padding_bytes"/>
				<el type="branchoffset_wide" id="defaultOffset"/>
				<el type="int" id="low"/>
				<el type="int" id="high"/>
				<list count="$high - $low + 1" id="jumpOffsets">
					<el type="branchoffset_wide" id="jumpOffset"/>
				</list>
			</std>
		</format>
	</instruction>
	<instruction name="wide" opcode="196">
		<operation>Extend local variable index by additional bytes</operation>
		<format>
			<std>
				<el type="mnemonic"/>
			</std>
		</format>
	</instruction>
</instructions>
