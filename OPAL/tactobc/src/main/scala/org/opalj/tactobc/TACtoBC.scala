/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj.tactobc

import java.io.File
import scala.collection.mutable

import org.opalj.ba.CodeElement
import org.opalj.br.Method
import org.opalj.br.analyses.Project
import org.opalj.tac._
import org.opalj.value.ValueInformation

object TACtoBC {

    /**
     * Compiles the Three-Address Code (TAC) representation for all methods in the given .class file.
     *
     * @param file A File object representing the .class file to be analyzed and compiled into TAC.
     * @return A Map associating each method in the class file with its corresponding TAC representation.
     */
    def compileTACFromClassFile(file: File): Map[Method, AITACode[TACMethodParameter, ValueInformation]] = {
        val p = Project(file)
        val tacProvider = p.get(LazyDetachedTACAIKey)

        // Store the TAC results in a map
        val methodTACMap = mutable.Map.empty[Method, AITACode[TACMethodParameter, ValueInformation]]

        for {
            cf <- p.allProjectClassFiles
            m <- cf.methods
            if m.body.isDefined
        } {
            val tac = tacProvider(m)
            methodTACMap += (m -> tac)
        }
        methodTACMap.toMap
    }

    /**
     * Compiles and prints the bytecode representation for all methods in the given .class file.
     *
     * @param file The .class file or JAR archive to be analyzed.
     * @return A Map associating each method in the class file with its bytecode instructions.
     */
    def compileByteCodeFromClassFile(file: File): Map[Method, Array[String]] = {
        val p = Project(file)

        // A map to store the bytecode representation of each method
        val methodByteCodeMap = scala.collection.mutable.Map.empty[Method, Array[String]]

        for {
            cf <- p.allProjectClassFiles
            method <- cf.methods
            if method.body.isDefined
        } {
            // Convert the body's instructions to a human-readable format
            val instructions = method.body.get.instructions.zipWithIndex.map { case (instr, index) =>
                s"$index: $instr"
            }
            methodByteCodeMap += (method -> instructions)
        }

        methodByteCodeMap.toMap
    }

    /**
     * Translates the TAC representations of methods back to bytecode, encapsulated within OPAL's Code structure.
     *
     * This method iterates over each method's TAC representation and generates a corresponding sequence of
     * bytecode instructions, effectively reversing the process of TAC generation.
     *
     * @param tacs A Map containing the TAC representations of methods to be translated back to bytecode.
     * @return A Map associating each method with its newly generated bytecode, wrapped in OPAL's Code structure.
     */
    def translateTACStoBC(tacs: Map[Method, AITACode[TACMethodParameter, ValueInformation]]): Map[
        Method,
        Seq[CodeElement[Nothing]]
    ] = {
        tacs.map { case (method, tacCode) =>
            // Convert the TAC representation back to bytecode for each method
            val bytecodeInstructions = translateSingleTACtoBC(method, tacCode)
            method -> bytecodeInstructions
        }
    }

    /**
     * Converts the TAC Stmts of a single method into bytecode instructions.
     *
     * This helper method processes one method's TAC representation at a time, converting it into a sequence
     * of bytecode instructions. It handles various types of TAC statements and expressions, translating them
     * into their equivalent bytecode form.
     *
     * @param method method to be translated
     * @param tac TAC representation of a method to be converted into bytecode.
     * @return A Sequence of bytecode instructions representing the method's functionality
     */
    private def translateSingleTACtoBC(
        method: Method,
        tac:    AITACode[TACMethodParameter, ValueInformation]
    ): Seq[CodeElement[Nothing]] = {
        val tacStmts = tac.stmts.zipWithIndex
        // fill uVarToLVIndexMap
        val uVarToLVIndex = LvIndicesPreparation.prepareLvIndices(method, tacStmts)
        StmtToInstructionTranslator.translateStmtsToInstructions(tacStmts, uVarToLVIndex)
    }
}
