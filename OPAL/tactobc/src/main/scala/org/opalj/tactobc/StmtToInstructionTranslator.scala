package org.opalj.tactobc

import scala.collection.mutable

import org.opalj.ba.CodeElement
import org.opalj.ba.LabelElement
import org.opalj.br.instructions.POP
import org.opalj.br.instructions.POP2
import org.opalj.br.instructions.RewriteLabel
import org.opalj.collection.immutable.IntTrieSet
import org.opalj.tac._
import org.opalj.value.ValueInformation

/**
 * Handles the translation of three-address code (TAC) statements
 * into Java bytecode instructions.
 *
 * This object processes each TAC statement and generates corresponding bytecode instructions,
 * updating the program counter (PC) as it proceeds.
 *
 * Key responsibilities:
 * - Translate TAC statements to bytecode instructions.
 * - Maintain mappings from TAC targets to bytecode program counters (PCs).
 */
object StmtToInstructionTranslator {

    /**
     * Translates TAC statements to bytecode instructions.
     *
     * This method iterates over the given TAC statements, processes each statement according to its type,
     * generates the corresponding bytecode instructions, and updates the program counter (PC) according to the instruction length.
     *
     * The `-1` value is used as a placeholder for statements that do not require a target.
     *
     * @param tacStmts Array of tuples where each tuple contains a TAC statement and its index.
     * @param generatedByteCodeWithPC ArrayBuffer to store the generated bytecode instructions along with their PCs.
     * @param tacTargetToByteCodePcs ArrayBuffer to map TAC targets to bytecode PCs.
     * @param switchCases ArrayBuffer to store switch case mappings.
     */
    def translateStmtsToInstructions(
        tacStmts:      Array[(Stmt[DUVar[ValueInformation]], Int)],
        uVarToLVIndex: mutable.Map[IntTrieSet, Int]
    ): Seq[CodeElement[Nothing]] = {

        // Indexes with their mapped labels
        val indexMap = tacStmts.map(_ => RewriteLabel())

        // Result which will be returned at the end of the function
        val listedCodeElements = mutable.ListBuffer[CodeElement[Nothing]]()

        // zipWithIndex -> every Tac-Stmt gets its own index -> allows finding the right Label in the indexMap
        tacStmts.zipWithIndex.foreach { case ((stmt, _), tacIndex) =>
            // label creation
            listedCodeElements += LabelElement(indexMap(tacIndex))
            stmt match {
                case Assignment(_, targetVar, expr) =>
                    StmtProcessor.processAssignment(targetVar, expr, uVarToLVIndex, listedCodeElements)
                case ArrayStore(_, arrayRef, index, value) =>
                    StmtProcessor.processArrayStore(arrayRef, index, value, uVarToLVIndex, listedCodeElements)
                case CaughtException(_, exceptionType, throwingStmts) =>
                    // todo
                    StmtProcessor.processCaughtException(
                        exceptionType,
                        throwingStmts,
                        listedCodeElements,
                        tacStmts,
                        indexMap,
                        tacIndex
                    )
                case ExprStmt(_, expr) =>
                    ExprProcessor.processExpression(expr, uVarToLVIndex, listedCodeElements)
                    listedCodeElements += (if (expr.cTpe.isCategory2) POP2 else POP)
                case If(_, left, condition, right, target) =>
                    StmtProcessor.processIf(left, condition, right, indexMap(target), uVarToLVIndex, listedCodeElements)
                case Goto(_, target) =>
                    StmtProcessor.processGoto(indexMap(target), listedCodeElements)
                case Switch(_, defaultTarget, index, npairs) =>
                    StmtProcessor.processSwitch(
                        indexMap(defaultTarget),
                        index,
                        npairs,
                        uVarToLVIndex,
                        listedCodeElements,
                        indexMap
                    )
                case JSR(_, target) =>
                    StmtProcessor.processJSR(indexMap(target), listedCodeElements)
                case VirtualMethodCall(_, declaringClass, isInterface, name, descriptor, receiver, params) =>
                    StmtProcessor.processVirtualMethodCall(
                        declaringClass,
                        isInterface,
                        name,
                        descriptor,
                        receiver,
                        params,
                        uVarToLVIndex,
                        listedCodeElements
                    )
                case NonVirtualMethodCall(_, declaringClass, isInterface, name, descriptor, receiver, params) =>
                    StmtProcessor.processNonVirtualMethodCall(
                        declaringClass,
                        isInterface,
                        name,
                        descriptor,
                        receiver,
                        params,
                        uVarToLVIndex,
                        listedCodeElements
                    )
                case StaticMethodCall(_, declaringClass, isInterface, name, descriptor, params) =>
                    StmtProcessor.processStaticMethodCall(
                        declaringClass,
                        isInterface,
                        name,
                        descriptor,
                        params,
                        uVarToLVIndex,
                        listedCodeElements
                    )
                case InvokedynamicMethodCall(_, bootstrapMethod, name, descriptor, params) =>
                    StmtProcessor.processInvokeDynamicMethodCall(
                        bootstrapMethod,
                        name,
                        descriptor,
                        params,
                        uVarToLVIndex,
                        listedCodeElements
                    )
                case MonitorEnter(_, objRef) =>
                    StmtProcessor.processMonitorEnter(objRef, uVarToLVIndex, listedCodeElements)
                case MonitorExit(_, objRef) =>
                    StmtProcessor.processMonitorExit(objRef, uVarToLVIndex, listedCodeElements)
                case PutField(_, declaringClass, name, declaredFieldType, objRef, value) =>
                    StmtProcessor.processPutField(
                        declaringClass,
                        name,
                        declaredFieldType,
                        objRef,
                        value,
                        uVarToLVIndex,
                        listedCodeElements
                    )
                case PutStatic(_, declaringClass, name, declaredFieldType, value) =>
                    StmtProcessor.processPutStatic(
                        declaringClass,
                        name,
                        declaredFieldType,
                        value,
                        uVarToLVIndex,
                        listedCodeElements
                    )
                case Checkcast(_, value, cmpTpe) =>
                    StmtProcessor.processCheckCast(value, cmpTpe, uVarToLVIndex, listedCodeElements)
                case Ret(_, returnAddresses) =>
                    StmtProcessor.processRet(returnAddresses, listedCodeElements)
                case ReturnValue(_, expr) =>
                    StmtProcessor.processReturnValue(expr, uVarToLVIndex, listedCodeElements)
                case Return(_) =>
                    StmtProcessor.processReturn(listedCodeElements)
                case Throw(_, exception) =>
                    StmtProcessor.processThrow(exception, uVarToLVIndex, listedCodeElements)
                case Nop(_) =>
                    StmtProcessor.processNop(listedCodeElements)
                case _ => throw new UnsupportedOperationException()
            }
        }
        listedCodeElements.toSeq
    }

}
