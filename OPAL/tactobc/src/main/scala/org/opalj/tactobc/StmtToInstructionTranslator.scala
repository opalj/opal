package org.opalj.tactobc

import scala.collection.immutable.ArraySeq
import scala.collection.mutable

import org.opalj.ba.CodeElement
import org.opalj.ba.LabelElement
import org.opalj.br.instructions.RewriteLabel
import org.opalj.collection.immutable.IntIntPair
import org.opalj.collection.immutable.IntTrieSet
import org.opalj.tac._
import org.opalj.value.ValueInformation

/**
 * Handles the translation of three-address code (TAC) statements
 * into Java bytecode instructions.
 *
 * This object processes each TAC statement and generates corresponding bytecode instructions,
 * updating the program counter (PC) as it proceeds.
 *
 * Key responsibilities:
 * - Translate TAC statements to bytecode instructions.
 * - Maintain mappings from TAC targets to bytecode program counters (PCs).
 */
object StmtToInstructionTranslator {

    /**
     * Translates TAC statements to bytecode instructions.
     *
     * This method iterates over the given TAC statements, processes each statement according to its type,
     * generates the corresponding bytecode instructions, and updates the program counter (PC) according to the instruction length.
     *
     * The `-1` value is used as a placeholder for statements that do not require a target.
     *
     * @param tacStmts Array of tuples where each tuple contains a TAC statement and its index.
     * @param generatedByteCodeWithPC ArrayBuffer to store the generated bytecode instructions along with their PCs.
     * @param tacTargetToByteCodePcs ArrayBuffer to map TAC targets to bytecode PCs.
     * @param switchCases ArrayBuffer to store switch case mappings.
     */
    def translateStmtsToInstructions(
        tacStmts:      Array[(Stmt[DUVar[ValueInformation]], Int)],
        uVarToLVIndex: mutable.Map[IntTrieSet, Int]
    ): Seq[CodeElement[Nothing]] = {

        // Indexes with their mapped labels
        val indexMap = tacStmts.map(_ => RewriteLabel())

        // Result which will be returned at the end of the function
        val listedCodeElements = mutable.ListBuffer[CodeElement[Nothing]]()

        // zipWithIndex -> every Tac-Stmt gets its own index -> allows finding the right Label in the indexMap
        tacStmts.zipWithIndex.foreach { case ((stmt, _), tacIndex) =>
            // Add the corresponding label, which will be followed by its instructions
            listedCodeElements += LabelElement(indexMap(tacIndex))
            stmt match {
                case Assignment(_, targetVar, expr) =>
                    // Add the InstructionElements to the List
                    listedCodeElements ++= StmtProcessor.processAssignment(targetVar, expr, uVarToLVIndex)
                case ArrayStore(_, arrayRef, index, value) =>
                    listedCodeElements ++= StmtProcessor.processArrayStore(arrayRef, index, value, uVarToLVIndex)
                case CaughtException(_, exceptionType, throwingStmts) =>
                    // todo
                    listedCodeElements ++= StmtProcessor.processCaughtException(exceptionType, throwingStmts)
                case ExprStmt(_, expr) =>
                    listedCodeElements ++= ExprProcessor.processExpression(expr, uVarToLVIndex)
                case If(_, left, condition, right, target) =>
                    listedCodeElements ++= StmtProcessor.processIf(
                        left,
                        condition,
                        right,
                        indexMap(target),
                        uVarToLVIndex
                    )
                case Goto(_, target) =>
                    listedCodeElements ++= StmtProcessor.processGoto(indexMap(target))
                case Switch(_, defaultTarget, index, npairs) =>
                    val labeledNpairs: ArraySeq[(Int, RewriteLabel)] = npairs.map({ case IntIntPair(key, value) =>
                        val label = indexMap(value)
                        (key, label)
                    })
                    listedCodeElements ++= StmtProcessor.processSwitch(
                        indexMap(defaultTarget),
                        index,
                        labeledNpairs,
                        uVarToLVIndex
                    )
                case JSR(_, target) =>
                    listedCodeElements ++= StmtProcessor.processJSR(indexMap(target))
                case VirtualMethodCall(_, declaringClass, isInterface, name, descriptor, receiver, params) =>
                    listedCodeElements ++= StmtProcessor.processVirtualMethodCall(
                        declaringClass,
                        isInterface,
                        name,
                        descriptor,
                        receiver,
                        params,
                        uVarToLVIndex
                    )
                case NonVirtualMethodCall(_, declaringClass, isInterface, name, descriptor, receiver, params) =>
                    listedCodeElements ++= StmtProcessor.processNonVirtualMethodCall(
                        declaringClass,
                        isInterface,
                        name,
                        descriptor,
                        receiver,
                        params,
                        uVarToLVIndex
                    )
                case StaticMethodCall(_, declaringClass, isInterface, name, descriptor, params) =>
                    listedCodeElements ++= StmtProcessor.processStaticMethodCall(
                        declaringClass,
                        isInterface,
                        name,
                        descriptor,
                        params,
                        uVarToLVIndex
                    )
                case InvokedynamicMethodCall(_, bootstrapMethod, name, descriptor, params) =>
                    listedCodeElements ++= StmtProcessor.processInvokeDynamicMethodCall(
                        bootstrapMethod,
                        name,
                        descriptor,
                        params,
                        uVarToLVIndex
                    )
                case MonitorEnter(_, objRef) =>
                    listedCodeElements ++= StmtProcessor.processMonitorEnter(objRef, uVarToLVIndex)
                case MonitorExit(_, objRef) =>
                    listedCodeElements ++= StmtProcessor.processMonitorExit(objRef, uVarToLVIndex)
                case PutField(_, declaringClass, name, declaredFieldType, objRef, value) =>
                    listedCodeElements ++= StmtProcessor.processPutField(
                        declaringClass,
                        name,
                        declaredFieldType,
                        objRef,
                        value,
                        uVarToLVIndex
                    )
                case PutStatic(_, declaringClass, name, declaredFieldType, value) =>
                    listedCodeElements ++= StmtProcessor.processPutStatic(
                        declaringClass,
                        name,
                        declaredFieldType,
                        value,
                        uVarToLVIndex
                    )
                case Checkcast(_, value, cmpTpe) =>
                    listedCodeElements ++= StmtProcessor.processCheckCast(value, cmpTpe, uVarToLVIndex)
                case Ret(_, returnAddresses) =>
                    listedCodeElements ++= StmtProcessor.processRet(returnAddresses)
                case ReturnValue(_, expr) =>
                    listedCodeElements ++= StmtProcessor.processReturnValue(expr, uVarToLVIndex)
                case Return(_) =>
                    listedCodeElements ++= StmtProcessor.processReturn()
                case Throw(_, exception) =>
                    listedCodeElements ++= StmtProcessor.processThrow(exception, uVarToLVIndex)
                case Nop(_) =>
                    listedCodeElements ++= StmtProcessor.processNop()
                case _ =>
            }
        }

        listedCodeElements.toSeq
    }

}
